{"version":3,"file":"epub-parser.worker-BFsmoAS_.js","sources":["../rsvp-reader/src/lib/workers/epub-parser.worker.js"],"sourcesContent":["self.onmessage = async (e) => {\n  const { file, bookId } = e.data;\n  \n  try {\n    const arrayBuffer = await file.arrayBuffer();\n    \n    // Use JSZip to extract EPUB (EPUBs are just ZIP files)\n    // We'll parse it manually since epubjs has issues in workers\n    \n    // For now, let's use a simpler approach with epub.js\n    const { default: ePub } = await import('epubjs');\n    \n    const book = ePub(arrayBuffer);\n    await book.opened;\n    \n    const tokens = [];\n    let tokenIdx = 0;\n    let chapterNum = 0;\n    \n    // Get all spine items (chapters)\n    const spine = book.spine.items;\n    const totalChapters = spine.length;\n    \n    for (const item of spine) {\n      chapterNum++;\n      \n      try {\n        // Load the chapter content\n        await item.load(book.load.bind(book));\n        \n        // Get text content from the document\n        const doc = item.document;\n        if (!doc || !doc.body) continue;\n        \n        // Extract all text from body\n        const text = doc.body.textContent || doc.body.innerText || '';\n        \n        // Split into words and clean\n        const words = text\n          .split(/\\s+/)\n          .map(w => w.trim())\n          .filter(w => w.length > 0);\n        \n        // Add each word as a token\n        words.forEach((word) => {\n          tokens.push({\n            bookId,\n            tokenIdx: tokenIdx++,\n            word: word,\n            page: chapterNum, // Use chapter number as \"page\"\n            bbox: null, // EPUB doesn't have fixed positions\n          });\n        });\n        \n        // Unload to free memory\n        item.unload();\n        \n      } catch (err) {\n        console.error(`Error parsing chapter ${chapterNum}:`, err);\n      }\n      \n      // Report progress\n      self.postMessage({\n        type: 'progress',\n        page: chapterNum,\n        total: totalChapters,\n      });\n    }\n    \n    self.postMessage({\n      type: 'complete',\n      tokens,\n      numPages: chapterNum,\n      totalWords: tokens.length,\n    });\n    \n  } catch (error) {\n    console.error('EPUB parse error:', error);\n    self.postMessage({\n      type: 'error',\n      error: error.message || 'Failed to parse EPUB',\n    });\n  }\n};\n"],"names":["e","file","bookId","arrayBuffer","ePub","book","tokens","tokenIdx","chapterNum","spine","totalChapters","item","doc","w","word","err","error"],"mappings":"AAAA,KAAK,UAAY,MAAOA,GAAM,CAC5B,KAAM,CAAE,KAAAC,EAAM,OAAAC,CAAM,EAAKF,EAAE,KAE3B,GAAI,CACF,MAAMG,EAAc,MAAMF,EAAK,YAAW,EAMpC,CAAE,QAASG,GAAS,KAAM,QAAO,qBAAQ,EAEzCC,EAAOD,EAAKD,CAAW,EAC7B,MAAME,EAAK,OAEX,MAAMC,EAAS,CAAA,EACf,IAAIC,EAAW,EACXC,EAAa,EAGjB,MAAMC,EAAQJ,EAAK,MAAM,MACnBK,EAAgBD,EAAM,OAE5B,UAAWE,KAAQF,EAAO,CACxBD,IAEA,GAAI,CAEF,MAAMG,EAAK,KAAKN,EAAK,KAAK,KAAKA,CAAI,CAAC,EAGpC,MAAMO,EAAMD,EAAK,SACjB,GAAI,CAACC,GAAO,CAACA,EAAI,KAAM,UAGVA,EAAI,KAAK,aAAeA,EAAI,KAAK,WAAa,IAIxD,MAAM,KAAK,EACX,IAAIC,GAAKA,EAAE,KAAI,CAAE,EACjB,OAAOA,GAAKA,EAAE,OAAS,CAAC,EAGrB,QAASC,GAAS,CACtBR,EAAO,KAAK,CACV,OAAAJ,EACA,SAAUK,IACV,KAAMO,EACN,KAAMN,EACN,KAAM,IAClB,CAAW,CACH,CAAC,EAGDG,EAAK,OAAM,CAEb,OAASI,EAAK,CACZ,QAAQ,MAAM,yBAAyBP,CAAU,IAAKO,CAAG,CAC3D,CAGA,KAAK,YAAY,CACf,KAAM,WACN,KAAMP,EACN,MAAOE,CACf,CAAO,CACH,CAEA,KAAK,YAAY,CACf,KAAM,WACN,OAAAJ,EACA,SAAUE,EACV,WAAYF,EAAO,MACzB,CAAK,CAEH,OAASU,EAAO,CACd,QAAQ,MAAM,oBAAqBA,CAAK,EACxC,KAAK,YAAY,CACf,KAAM,QACN,MAAOA,EAAM,SAAW,sBAC9B,CAAK,CACH,CACF"}